"""
This type stub file was generated by pyright.
"""

import shapely

"""Base geometry class and utilities

Note: a third, z, coordinate value may be used when constructing
geometry objects, but has no effect on geometric analysis. All
operations are performed in the x-y plane. Thus, geometries with
different z values may intersect or be equal.
"""
GEOMETRY_TYPES = ...
def geom_factory(g, parent=...):
    """
    Creates a Shapely geometry instance from a pointer to a GEOS geometry.

    .. warning::
        The GEOS library used to create the the GEOS geometry pointer
        and the GEOS library used by Shapely must be exactly the same, or
        unexpected results or segfaults may occur.

    .. deprecated:: 2.0
        Deprecated in Shapely 2.0, and will be removed in a future version.
    """
    ...

def dump_coords(geom): # -> tuple[Unknown, ...] | list[Unknown]:
    """Dump coordinates of a geometry in the same order as data packing"""
    ...

class CAP_STYLE:
    round = ...
    flat = ...
    square = ...


class JOIN_STYLE:
    round = ...
    mitre = ...
    bevel = ...


class BaseGeometry(shapely.Geometry):
    """
    Provides GEOS spatial predicates and topological operations.

    """
    __slots__ = ...
    def __new__(self):
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __nonzero__(self): # -> bool:
        ...
    
    def __format__(self, format_spec):
        """Format a geometry using a format specification."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __reduce__(self): # -> tuple[(geometry: Unknown, on_invalid: str = "raise", **kwargs: Unknown) -> Unknown, tuple[Unknown]]:
        ...
    
    def __and__(self, other):
        ...
    
    def __or__(self, other):
        ...
    
    def __sub__(self, other):
        ...
    
    def __xor__(self, other):
        ...
    
    @property
    def coords(self): # -> CoordinateSequence:
        """Access to geometry's coordinates (CoordinateSequence)"""
        ...
    
    @property
    def xy(self):
        """Separate arrays of X and Y coordinate values"""
        ...
    
    @property
    def __geo_interface__(self):
        """Dictionary representation of the geometry"""
        ...
    
    def geometryType(self):
        ...
    
    @property
    def type(self):
        ...
    
    @property
    def wkt(self):
        """WKT representation of the geometry"""
        ...
    
    @property
    def wkb(self):
        """WKB representation of the geometry"""
        ...
    
    @property
    def wkb_hex(self):
        """WKB hex representation of the geometry"""
        ...
    
    def svg(self, scale_factor=..., **kwargs):
        """Raises NotImplementedError"""
        ...
    
    @property
    def geom_type(self):
        """Name of the geometry's type, such as 'Point'"""
        ...
    
    @property
    def area(self): # -> float:
        """Unitless area of the geometry (float)"""
        ...
    
    def distance(self, other):
        """Unitless distance to other geometry (float)"""
        ...
    
    def hausdorff_distance(self, other):
        """Unitless hausdorff distance to other geometry (float)"""
        ...
    
    @property
    def length(self): # -> float:
        """Unitless length of the geometry (float)"""
        ...
    
    @property
    def minimum_clearance(self): # -> float:
        """Unitless distance by which a node could be moved to produce an invalid geometry (float)"""
        ...
    
    @property
    def boundary(self):
        """Returns a lower dimension geometry that bounds the object

        The boundary of a polygon is a line, the boundary of a line is a
        collection of points. The boundary of a point is an empty (null)
        collection.
        """
        ...
    
    @property
    def bounds(self): # -> tuple[Unknown, ...]:
        """Returns minimum bounding region (minx, miny, maxx, maxy)"""
        ...
    
    @property
    def centroid(self):
        """Returns the geometric center of the object"""
        ...
    
    def point_on_surface(self):
        """Returns a point guaranteed to be within the object, cheaply.

        Alias of `representative_point`.
        """
        ...
    
    def representative_point(self):
        """Returns a point guaranteed to be within the object, cheaply.

        Alias of `point_on_surface`.
        """
        ...
    
    @property
    def convex_hull(self):
        """Imagine an elastic band stretched around the geometry: that's a
        convex hull, more or less

        The convex hull of a three member multipoint, for example, is a
        triangular polygon.
        """
        ...
    
    @property
    def envelope(self):
        """A figure that envelopes the geometry"""
        ...
    
    @property
    def oriented_envelope(self):
        """
        Returns the oriented envelope (minimum rotated rectangle) that
        encloses the geometry.

        Unlike envelope this rectangle is not constrained to be parallel to the
        coordinate axes. If the convex hull of the object is a degenerate (line
        or point) this degenerate is returned.

        Alias of `minimum_rotated_rectangle`.
        """
        ...
    
    @property
    def minimum_rotated_rectangle(self):
        """
        Returns the oriented envelope (minimum rotated rectangle) that
        encloses the geometry.

        Unlike `envelope` this rectangle is not constrained to be parallel to the
        coordinate axes. If the convex hull of the object is a degenerate (line
        or point) this degenerate is returned.

        Alias of `oriented_envelope`.
        """
        ...
    
    def buffer(self, distance, quad_segs=..., cap_style=..., join_style=..., mitre_limit=..., single_sided=..., **kwargs):
        """Get a geometry that represents all points within a distance
        of this geometry.

        A positive distance produces a dilation, a negative distance an
        erosion. A very small or zero distance may sometimes be used to
        "tidy" a polygon.

        Parameters
        ----------
        distance : float
            The distance to buffer around the object.
        resolution : int, optional
            The resolution of the buffer around each vertex of the
            object.
        quad_segs : int, optional
            Sets the number of line segments used to approximate an
            angle fillet.
        cap_style : shapely.BufferCapStyle or {'round', 'square', 'flat'}, default 'round'
            Specifies the shape of buffered line endings. BufferCapStyle.round ('round')
            results in circular line endings (see ``quad_segs``). Both BufferCapStyle.square
            ('square') and BufferCapStyle.flat ('flat') result in rectangular line endings,
            only BufferCapStyle.flat ('flat') will end at the original vertex,
            while BufferCapStyle.square ('square') involves adding the buffer width.
        join_style : shapely.BufferJoinStyle or {'round', 'mitre', 'bevel'}, default 'round'
            Specifies the shape of buffered line midpoints. BufferJoinStyle.ROUND ('round')
            results in rounded shapes. BufferJoinStyle.bevel ('bevel') results in a beveled
            edge that touches the original vertex. BufferJoinStyle.mitre ('mitre') results
            in a single vertex that is beveled depending on the ``mitre_limit`` parameter.
        mitre_limit : float, optional
            The mitre limit ratio is used for very sharp corners. The
            mitre ratio is the ratio of the distance from the corner to
            the end of the mitred offset corner. When two line segments
            meet at a sharp angle, a miter join will extend the original
            geometry. To prevent unreasonable geometry, the mitre limit
            allows controlling the maximum length of the join corner.
            Corners with a ratio which exceed the limit will be beveled.
        single_side : bool, optional
            The side used is determined by the sign of the buffer
            distance:

                a positive distance indicates the left-hand side
                a negative distance indicates the right-hand side

            The single-sided buffer of point geometries is the same as
            the regular buffer.  The End Cap Style for single-sided
            buffers is always ignored, and forced to the equivalent of
            CAP_FLAT.
        quadsegs : int, optional
            Deprecated alias for `quad_segs`.

        Returns
        -------
        Geometry

        Notes
        -----
        The return value is a strictly two-dimensional geometry. All
        Z coordinates of the original geometry will be ignored.

        Examples
        --------
        >>> from shapely.wkt import loads
        >>> g = loads('POINT (0.0 0.0)')

        16-gon approx of a unit radius circle:

        >>> g.buffer(1.0).area  # doctest: +ELLIPSIS
        3.1365484905459...

        128-gon approximation:

        >>> g.buffer(1.0, 128).area  # doctest: +ELLIPSIS
        3.141513801144...

        triangle approximation:

        >>> g.buffer(1.0, 3).area
        3.0
        >>> list(g.buffer(1.0, cap_style=BufferCapStyle.square).exterior.coords)
        [(1.0, 1.0), (1.0, -1.0), (-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0)]
        >>> g.buffer(1.0, cap_style=BufferCapStyle.square).area
        4.0

        """
        ...
    
    def simplify(self, tolerance, preserve_topology=...):
        """Returns a simplified geometry produced by the Douglas-Peucker
        algorithm

        Coordinates of the simplified geometry will be no more than the
        tolerance distance from the original. Unless the topology preserving
        option is used, the algorithm may produce self-intersecting or
        otherwise invalid geometries.
        """
        ...
    
    def normalize(self):
        """Converts geometry to normal form (or canonical form).

        This method orders the coordinates, rings of a polygon and parts of
        multi geometries consistently. Typically useful for testing purposes
        (for example in combination with `equals_exact`).

        Examples
        --------
        >>> from shapely import MultiLineString
        >>> line = MultiLineString([[(0, 0), (1, 1)], [(3, 3), (2, 2)]])
        >>> line.normalize()
        <MULTILINESTRING ((2 2, 3 3), (0 0, 1 1))>
        """
        ...
    
    def difference(self, other, grid_size=...):
        """
        Returns the difference of the geometries.

        Refer to `shapely.difference` for full documentation.
        """
        ...
    
    def intersection(self, other, grid_size=...):
        """
        Returns the intersection of the geometries.

        Refer to `shapely.intersection` for full documentation.
        """
        ...
    
    def symmetric_difference(self, other, grid_size=...):
        """
        Returns the symmetric difference of the geometries.

        Refer to `shapely.symmetric_difference` for full documentation.
        """
        ...
    
    def union(self, other, grid_size=...):
        """
        Returns the union of the geometries.

        Refer to `shapely.union` for full documentation.
        """
        ...
    
    @property
    def has_z(self): # -> bool:
        """True if the geometry's coordinate sequence(s) have z values (are
        3-dimensional)"""
        ...
    
    @property
    def is_empty(self): # -> bool:
        """True if the set of points in this geometry is empty, else False"""
        ...
    
    @property
    def is_ring(self): # -> bool:
        """True if the geometry is a closed ring, else False"""
        ...
    
    @property
    def is_closed(self): # -> bool:
        """True if the geometry is closed, else False

        Applicable only to 1-D geometries."""
        ...
    
    @property
    def is_simple(self): # -> bool:
        """True if the geometry is simple, meaning that any self-intersections
        are only at boundary points, else False"""
        ...
    
    @property
    def is_valid(self): # -> bool:
        """True if the geometry is valid (definition depends on sub-class),
        else False"""
        ...
    
    def relate(self, other):
        """Returns the DE-9IM intersection matrix for the two geometries
        (string)"""
        ...
    
    def covers(self, other):
        """Returns True if the geometry covers the other, else False"""
        ...
    
    def covered_by(self, other):
        """Returns True if the geometry is covered by the other, else False"""
        ...
    
    def contains(self, other):
        """Returns True if the geometry contains the other, else False"""
        ...
    
    def contains_properly(self, other):
        """
        Returns True if the geometry completely contains the other, with no
        common boundary points, else False

        Refer to `shapely.contains_properly` for full documentation.
        """
        ...
    
    def crosses(self, other):
        """Returns True if the geometries cross, else False"""
        ...
    
    def disjoint(self, other):
        """Returns True if geometries are disjoint, else False"""
        ...
    
    def equals(self, other):
        """Returns True if geometries are equal, else False.

        This method considers point-set equality (or topological
        equality), and is equivalent to (self.within(other) &
        self.contains(other)).

        Examples
        --------
        >>> LineString(
        ...     [(0, 0), (2, 2)]
        ... ).equals(
        ...     LineString([(0, 0), (1, 1), (2, 2)])
        ... )
        True

        Returns
        -------
        bool

        """
        ...
    
    def intersects(self, other):
        """Returns True if geometries intersect, else False"""
        ...
    
    def overlaps(self, other):
        """Returns True if geometries overlap, else False"""
        ...
    
    def touches(self, other):
        """Returns True if geometries touch, else False"""
        ...
    
    def within(self, other):
        """Returns True if geometry is within the other, else False"""
        ...
    
    def dwithin(self, other, distance):
        """
        Returns True if geometry is within a given distance from the other, else False.

        Refer to `shapely.dwithin` for full documentation.
        """
        ...
    
    def equals_exact(self, other, tolerance):
        """True if geometries are equal to within a specified
        tolerance.

        Parameters
        ----------
        other : BaseGeometry
            The other geometry object in this comparison.
        tolerance : float
            Absolute tolerance in the same units as coordinates.

        This method considers coordinate equality, which requires
        coordinates to be equal and in the same order for all components
        of a geometry.

        Because of this it is possible for "equals()" to be True for two
        geometries and "equals_exact()" to be False.

        Examples
        --------
        >>> LineString(
        ...     [(0, 0), (2, 2)]
        ... ).equals_exact(
        ...     LineString([(0, 0), (1, 1), (2, 2)]),
        ...     1e-6
        ... )
        False

        Returns
        -------
        bool

        """
        ...
    
    def almost_equals(self, other, decimal=...):
        """True if geometries are equal at all coordinates to a
        specified decimal place.

        .. deprecated:: 1.8.0
            The 'almost_equals()' method is deprecated
            and will be removed in Shapely 2.1 because the name is
            confusing. The 'equals_exact()' method should be used
            instead.

        Refers to approximate coordinate equality, which requires
        coordinates to be approximately equal and in the same order for
        all components of a geometry.

        Because of this it is possible for "equals()" to be True for two
        geometries and "almost_equals()" to be False.

        Examples
        --------
        >>> LineString(
        ...     [(0, 0), (2, 2)]
        ... ).equals_exact(
        ...     LineString([(0, 0), (1, 1), (2, 2)]),
        ...     1e-6
        ... )
        False

        Returns
        -------
        bool

        """
        ...
    
    def relate_pattern(self, other, pattern):
        """Returns True if the DE-9IM string code for the relationship between
        the geometries satisfies the pattern, else False"""
        ...
    
    def line_locate_point(self, other, normalized=...):
        """Returns the distance along this geometry to a point nearest the
        specified point

        If the normalized arg is True, return the distance normalized to the
        length of the linear geometry.

        Alias of `project`.
        """
        ...
    
    def project(self, other, normalized=...):
        """Returns the distance along this geometry to a point nearest the
        specified point

        If the normalized arg is True, return the distance normalized to the
        length of the linear geometry.

        Alias of `line_locate_point`.
        """
        ...
    
    def line_interpolate_point(self, distance, normalized=...):
        """Return a point at the specified distance along a linear geometry

        Negative length values are taken as measured in the reverse
        direction from the end of the geometry. Out-of-range index
        values are handled by clamping them to the valid range of values.
        If the normalized arg is True, the distance will be interpreted as a
        fraction of the geometry's length.

        Alias of `interpolate`.
        """
        ...
    
    def interpolate(self, distance, normalized=...):
        """Return a point at the specified distance along a linear geometry

        Negative length values are taken as measured in the reverse
        direction from the end of the geometry. Out-of-range index
        values are handled by clamping them to the valid range of values.
        If the normalized arg is True, the distance will be interpreted as a
        fraction of the geometry's length.

        Alias of `line_interpolate_point`.
        """
        ...
    
    def segmentize(self, max_segment_length):
        """Adds vertices to line segments based on maximum segment length.

        Additional vertices will be added to every line segment in an input geometry
        so that segments are no longer than the provided maximum segment length. New
        vertices will evenly subdivide each segment.

        Only linear components of input geometries are densified; other geometries
        are returned unmodified.

        Parameters
        ----------
        max_segment_length : float or array_like
            Additional vertices will be added so that all line segments are no
            longer this value.  Must be greater than 0.

        Examples
        --------
        >>> from shapely import LineString, Polygon
        >>> LineString([(0, 0), (0, 10)]).segmentize(max_segment_length=5)
        <LINESTRING (0 0, 0 5, 0 10)>
        >>> Polygon([(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)]).segmentize(max_segment_length=5)
        <POLYGON ((0 0, 5 0, 10 0, 10 5, 10 10, 5 10, 0 10, 0 5, 0 0))>
        """
        ...
    
    def reverse(self):
        """Returns a copy of this geometry with the order of coordinates reversed.

        If the geometry is a polygon with interior rings, the interior rings are also
        reversed.

        Points are unchanged.

        See also
        --------
        is_ccw : Checks if a geometry is clockwise.

        Examples
        --------
        >>> from shapely import LineString, Polygon
        >>> LineString([(0, 0), (1, 2)]).reverse()
        <LINESTRING (1 2, 0 0)>
        >>> Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]).reverse()
        <POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))>
        """
        ...
    


class BaseMultipartGeometry(BaseGeometry):
    __slots__ = ...
    @property
    def coords(self):
        ...
    
    @property
    def geoms(self): # -> GeometrySequence:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def svg(self, scale_factor=..., color=...): # -> LiteralString | Literal['<g />']:
        """Returns a group of SVG elements for the multipart geometry.

        Parameters
        ==========
        scale_factor : float
            Multiplication factor for the SVG stroke-width.  Default is 1.
        color : str, optional
            Hex string for stroke or fill color. Default is to use "#66cc99"
            if geometry is valid, and "#ff3333" if invalid.
        """
        ...
    


class GeometrySequence:
    """
    Iterative access to members of a homogeneous multipart geometry.
    """
    _parent = ...
    def __init__(self, parent) -> None:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    def __len__(self):
        ...
    
    def __getitem__(self, key): # -> None:
        ...
    


class EmptyGeometry(BaseGeometry):
    def __new__(self):
        """Create an empty geometry."""
        ...
    


