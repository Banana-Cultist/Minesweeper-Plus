"""
This type stub file was generated by pyright.
"""

class Complex:
    def __init__(self, dim, func, func_args=..., symmetry=..., bounds=..., g_cons=..., g_args=...) -> None:
        ...
    
    def __call__(self): # -> list[Unknown]:
        ...
    
    def n_cube(self, dim, symmetry=..., printout=...): # -> None:
        """
        Generate the simplicial triangulation of the N-D hypercube
        containing 2**n vertices
        """
        ...
    
    def perm(self, i_parents, x_parents, xi): # -> None:
        ...
    
    def perm_symmetry(self, i_s, x_parents, xi): # -> None:
        ...
    
    def add_centroid(self): # -> None:
        """Split the central edge between the origin and supremum of
        a cell and add the new vertex to the complex"""
        ...
    
    def incidence(self): # -> None:
        ...
    
    def graph_map(self): # -> None:
        """ Make a list of size 2**n + 1 where an entry is a vertex
        incidence, each list element contains a list of indexes
        corresponding to that entries neighbors"""
        ...
    
    def sub_generate_cell(self, C_i, gen): # -> list[Unknown]:
        """Subgenerate a cell `C_i` of generation `gen` and
        homology group rank `hgr`."""
        ...
    
    def split_generation(self): # -> bool:
        """
        Run sub_generate_cell for every cell in the current complex self.gen
        """
        ...
    
    def construct_hypercube(self, origin, supremum, gen, hgr, printout=...): # -> Cell:
        """
        Build a hypercube with triangulations symmetric to C0.

        Parameters
        ----------
        origin : vec
        supremum : vec (tuple)
        gen : generation
        hgr : parent homology group rank
        """
        ...
    
    def split_simplex_symmetry(self, S, gen): # -> None:
        """
        Split a hypersimplex S into two sub simplices by building a hyperplane
        which connects to a new vertex on an edge (the longest edge in
        dim = {2, 3}) and every other vertex in the simplex that is not
        connected to the edge being split.

        This function utilizes the knowledge that the problem is specified
        with symmetric constraints

        The longest edge is tracked by an ordering of the
        vertices in every simplices, the edge between first and second
        vertex is the longest edge to be split in the next iteration.
        """
        ...
    
    def plot_complex(self): # -> None:
        """
             Here, C is the LIST of simplexes S in the
             2- or 3-D complex

             To plot a single simplex S in a set C, use e.g., [C[0]]
        """
        ...
    


class VertexGroup:
    def __init__(self, p_gen, p_hgr) -> None:
        ...
    
    def __call__(self): # -> list[Unknown]:
        ...
    
    def add_vertex(self, V): # -> None:
        ...
    
    def homology_group_rank(self): # -> int:
        """
        Returns the homology group order of the current cell
        """
        ...
    
    def homology_group_differential(self): # -> int:
        """
        Returns the difference between the current homology group of the
        cell and its parent group
        """
        ...
    
    def polytopial_sperner_lemma(self): # -> None:
        """
        Returns the number of stationary points theoretically contained in the
        cell based information currently known about the cell
        """
        ...
    
    def print_out(self): # -> None:
        """
        Print the current cell to console
        """
        ...
    


class Cell(VertexGroup):
    """
    Contains a cell that is symmetric to the initial hypercube triangulation
    """
    def __init__(self, p_gen, p_hgr, origin, supremum) -> None:
        ...
    


class Simplex(VertexGroup):
    """
    Contains a simplex that is symmetric to the initial symmetry constrained
    hypersimplex triangulation
    """
    def __init__(self, p_gen, p_hgr, generation_cycle, dim) -> None:
        ...
    


class Vertex:
    def __init__(self, x, bounds=..., func=..., func_args=..., g_cons=..., g_cons_args=..., nn=..., index=...) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def connect(self, v): # -> None:
        ...
    
    def disconnect(self, v): # -> None:
        ...
    
    def minimiser(self): # -> bool:
        """Check whether this vertex is strictly less than all its neighbors"""
        ...
    
    def print_out(self): # -> None:
        ...
    


class VertexCache:
    def __init__(self, func, func_args=..., bounds=..., g_cons=..., g_cons_args=..., indexed=...) -> None:
        ...
    
    def __getitem__(self, x, indexed=...):
        ...
    


